{"meta":{"title":":Sungju in Dev ;)","subtitle":"dev diary","description":null,"author":"Sungju Doh","url":"http://SungjuDoh.github.io"},"pages":[],"posts":[{"title":"nodejs blah blah","slug":"nodejs_1","date":"2018-09-12T14:32:08.498Z","updated":"2018-09-15T09:16:45.690Z","comments":true,"path":"2018/09/12/nodejs_1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/12/nodejs_1/","excerpt":"","text":"Filestream Module File I/O readFile 1234var fs = require('fs');fs.readFile('sample.txt', 'utf8', function(err, data)&#123; // data 이용한 코드&#125;); 파일명은 경로명을 포함하여 적고, 해당 파일로부터 utf-8 형식으로 data를 읽어온다. writeFile 123fs.writeFile(`data/$&#123;title&#125;`, data, 'utf8', function(err)&#123; // blah blah&#125;); 다음과 같이 data를 저장하는 파일을 생성할 수 있다. Readdir 123456var testFolder = '../data';var fs = require('fs');fs.readdir(testFolder, function(err, filelist)&#123; console.log(filelist);&#125;); 해당 directory에 있는 file들의 리스트를 찾아준다. filelist를 글 목록 등으로 사용 가능하다. Expression Languageblah blah ${표현식} blah blah... 형태로 사용된다.표현식으로는 변수, 객체의 속성, 배열의 원소 등이 사용된다. Urlurl.parse(_url, true) 에는 URL 상의 정보가 다음과 같이 저장되어 있다.1234567891011121314 &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: &apos;?id=introduce&apos;, query: &#123; id: &apos;introduce&apos; &#125;, pathname: &apos;/&apos;, path: &apos;/?id=introduce&apos;, href: &apos;/?id=introduce&apos;&#125; 다음과 같이 이 객체의 각 속성에 접근하여 유용하게 사용 가능하다.1234var app = http.createServer(function(request,response)&#123;var _url = request.url;var queryData = url.parse(_url, true).query;var pathname = url.parse(_url, true).pathname; Callback function123fs.readFile(`data/$&#123;queryData.id&#125;`, 'utf8', function(err, description)&#123; // here, code for callback function&#125;); 예시를 통해 callback 함수 를 쉽게 이해할 수 있다.위 예시의 경우 해당파일을 읽은 후, readFile의 3번째 인자로 전달된 callback 함수 가 실행된다. pm2npm 을 이용하여 pm2 를 설치한다.pm2 start main.js --watch : main.js 파일의 수정 사항을 자동으로 반영하며 실행pm2 list : 현재 pm2로 실행되고 있는 file listpm2 monitpm2 log : 현재 pm2로 실행되고 있는 file들의 상태; error 체크도 가능 Synchronize &amp; Asynchronize‘sample.txt’에는 ‘B’라는 내용이 저장되어있다. Synchronized code 1234console.log('A');//1var result = fs.readFileSync('./sample.txt', 'utf8');//2console.log(result);console.log('C');//3 위 코드를 실행시키면 A B C 순으로 출력된다. result에 파일을 읽어온 후에 이후의 코드가 실행되기 때문이다.하지만, 파일을 읽어오는 것은 상대적으로 긴 실행시간을 가지므로 효율성을 위해 비동기적 으로 실행시켜야한다 Asychronized code 12345console.log('A');//1fs.readFile('./sample.txt', 'utf8', function(err, result)&#123; console.log(result);//3&#125;);console.log('C');//2 위 코드를 실행시키면 A C B 순으로 출력된다. 파일을 읽어오는동안 C를 출력하고, 파일을 다 읽어온 후에 실행되는 callback 함수에서 B가 출력된다. CreateForm tag 를 이용하여 게시글을 작성한다. 12345678910// file: form.html&lt;form action=\"http://localhost:3000/process_create\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"title\"&gt;&lt;/p&gt; &lt;p&gt; &lt;textarea name=\"description\"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\"&gt; &lt;/p&gt;&lt;/form&gt; form 안의 각 content에 사용자가 넣은 정보를 submit 눌렀을때, Query String 의 형태로 action 에서 가리키는 서버애 데이터를 전송하는 html 의 기능이다.method 를 통해 전송방식을 설정할 수 있다. Default로는 method=&quot;get&quot;가 설정되고, 이 떄는 url을 통해 전달되는 데이터가 모두 표시된다.따라서, 단순한 읽기가 아닌 생성이나 수정가능한 경우에는 눈에 보이지 않는 방법으로 보내야한다. 이때는 method=&quot;post&quot;를 사용하면 되고, 긴 데이터를 전송할 때도 사용된다. post 방식으로 전송된 데이터눈에 보이지 않는 post 방식 으로 보내진 데이터는 어떻게 가져올 수 있을까.1234567891011121314151617var qs = require('querystring');var app = http.createServer(function(request,response)&#123; // request, response는 createServer의 callback 함수의 인자 var body = ''; request.on('data', function(data)&#123; body = body+data; &#125;); // data를 수신할 때마다 해당 callback 함수가 실행된다. request.on('end', function()&#123; var post = qs.parse(body); var title = post.title; var description = post.description; fs.writeFile(`data/$&#123;title&#125;`, description, 'utf8', function(err)&#123; response.writeHead(302, &#123;Location: `/?id=$&#123;title&#125;`&#125;); // redirection response.end(); &#125;);// 파일 생성에 성공하면 해당 callback함수가 실행된다. &#125;); // 정보수신이 끝났음을 의미&#125;); qs.parse(body)를 이용하여 post 방식으로 보내진 데이터를 다음고 같이 가져올 수 있다.0|main | { title: &#39;nodejs &#39;, description: &#39;nj is ...&#39; }이 객체의 각 속성에 접근하여 데이터를 사용하면 된다. 여기서 form 에 작성한 데이터는 게시글이다. fs.writeFile을 통해 입력된 data를 저장하는 파일을 생성한다. fs.writeFile을 통해 성공적으로 파일이 성공적으로 생성되면, 해당 callback 함수에서 리다이랙션 이 실행된다. 해당 Location으로 이동되는 것이다. Update작성된 게시글을 수정한다.&lt;a href=&quot;/update?id=${title}&quot;&gt;update&lt;/a&gt;update 링크 를 클릭하면 해당 링크로 이동한다. 이 링크를 클릭하면 글수정이 실행된다.123456789101112131415161718192021else if(pathname==='/update')&#123; fs.readdir('./data', function(error, filelist)&#123; fs.readFile(`data/$&#123;queryData.id&#125;`, 'utf8', function(err, description)&#123; var title = queryData.id; var list = templateList(filelist); var template = templateHTML(title, list, ` &lt;form action=\"/update_process\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"$&#123;title&#125;\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"title\" placeholder=\"title\" value=\"$&#123;title&#125;\"&gt;&lt;/p&gt; &lt;p&gt; &lt;textarea name=\"description\" placeholder=\"description\"&gt;$&#123;description&#125;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\"&gt; &lt;/p&gt; &lt;/form&gt;`, `&lt;a href=\"/create\"&gt;create&lt;/a&gt; &lt;a href=\"/update?id=$&#123;title&#125;\"&gt;update&lt;/a&gt;`); response.writeHead(200); response.end(template); &#125;); &#125;);&#125; 각 칸에 기존 글의 제목과 내용이 들어가 있도록 value를 설정한다.이 때 제목도 수정됐을 때에도 어느파일을 수정할 지 알 수 있도록 하기위해, 원제목 을 id 라는 hidden 칸에 저장하여 post 방식으로 /update_process로 전달한다. 123456789101112131415161718else if(pathname === '/update_process')&#123; var body = ''; request.on('data', function(data)&#123; body = body+data; &#125;); // 수신할 때 마다 해당 콜백함수를 호출하게 되어있다. request.on('end', function()&#123; var post = qs.parse(body); var id = post.id; var title = post.title; var description = post.description; fs.rename(`data/$&#123;id&#125;`, `data/$&#123;title&#125;`, function(error)&#123; fs.writeFile(`data/$&#123;title&#125;`, description, 'utf8', function(err)&#123; response.writeHead(302, &#123;Location: `/?id=$&#123;title&#125;`&#125;); response.end(); &#125;);// 파일 생성 성공시 &#125;)// 파일명 수정 &#125;); // 정보수신이 끝났음을 의미&#125; 원제목을 통해 수정할 파일을 찾아서 사용자가 입력한대로 수정한다. Delete작성된 게시글을 삭제한다. 데이터의 생성, 수정 등 변형을 실행하는 버튼은 링크로 생성하지 않도록 주의한다.1234&lt;form action=\"delete_process\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"$&#123;title&#125;\"&gt; &lt;input type=\"submit\" value=\"delete\"&gt;&lt;/form&gt; 해당 form 을 홈화면에 추가한다. 1234567891011121314else if(pathname === '/delete_process')&#123; var body = ''; request.on('data', function(data)&#123; body = body+data; &#125;); // 수신할 때 마다 해당 콜백함수를 호출하게 되어있다. request.on('end', function()&#123; var post = qs.parse(body); var id = post.id; fs.unlink(`data/$&#123;id&#125;`, function(error)&#123; response.writeHead(302, &#123;Location: `/`&#125;); response.end(); &#125;) &#125;); // 정보수신이 끝났음을 의미&#125; id라는 제목의 게시글을 위 코드와 같이 삭제한다. 객체객체와 배열은 다음과 같이 다르게 정의한다.12345678910111213// arrayvar members = ['egoing', 'k3', 'sungju'];// objectvar roles = &#123; 'programmer' : 'egoing', 'designer' : 'k3', 'manager' : 'sungju' f1 : function()&#123; console.log(this.designer); &#125;&#125;roles.f1(); // 객체 안의 함수 호출 객체는 각 성분에 대한 key값과 이에 상응하는 value를 가진다. object.key나 object[key]로 value를 사용할 수 있다.객체는 데이터와 처리방법을 담는 그릇이다. 객체의 value로 단순한 data 뿐 아니라 함수도 성분으로 가질 수 있다. 함수는 다른 statement와 달리 값을 가져서 변수에 함수를 저장할 수 있다. var a = function(){...} * this : 객체 안에서 자신의 객체를 참조하는 키워드 12345console.log(roles.designer);for(var name in object)&#123; console.log('key: ',name, ' value: ', object[name]);&#125; 다음과 같은 반복문에서 name은 key 값에 해당하고, value 에는 object[name]과 같이 접근할 수 있다. refactoring같은 동작을 하는 코드를 함수나 객체화, 배열화 하는 과정을 통해 유지보수가 쉬운 코드로 개선하는 것 Module위에서 살펴본 refactoring 방법으로 모듈화 가 있다.1234567var M = &#123; v: 'v', f: function()&#123; console.log(this.v); &#125;&#125;module.exports = M; 다음과 같이 M이 가진 기능을 module로 내보내면 다음 코드와 같이 해당 파일 밖에서도 사용가능하다.var part = require(&#39;./mpart.js&#39;); template처럼 복잡하고 긴 코드를 lib과 같은 폴더에서 모듈화시키면 훨씬 좋은 코드를 작성할 수 있다. 보안보안이 필요한 경우를 크게 두 가지로 살펴본다. 오염된 정보의 입력간단한 예시로 사용자가 ../ 등의 형태의 입력을 통해 상위폴더를 탐색할 수 있을 수도 있다. 따라서 입력된 경로정보를 안전하게 세탁하여 사용하는 것이 좋다. 123456var path = require('path');...var filteredId = path.parse(queryData.id).base;fs.readFile(`data/$&#123;filteredId&#125;`, 'utf8', function(err, description)&#123; ...&#125; 오염된 정보의 출력간단한 예시로 html 용어가 그대로 출력되지 않고, html 언어에 따라 실행되는 것을 방지한다. 먼저 다음과 같이 sanitize-html npm을 설치한다. 12npm initnpm install -S sanitize-html 그 후 필요한 입력 부분을 sanitize 시켜서 사용하면 된다. 123456var sanitizeHtml = require('sanitize-html');...var sanitizedTitle = sanitizeHtml(title);var html = template.html(title, list, `&lt;h2&gt;$&#123;sanitizedTitle&#125;&lt;/h2&gt;$&#123;sanitizedDescription&#125;`, ... More to Learn Webbrowser Database mongodb mysql Framework : 공통적인 실행을 하는 부분을 미리 구현해 놓은 것으로 사용을 위해 많은 공부가 필요하지만 아주 편리하다. Module/ Api Awesome 북마크 : node.js awesome 같은 검색어로 좋은 모듈을 찾을 수 있다.","categories":[{"name":"Web","slug":"Web","permalink":"http://SungjuDoh.github.io/categories/Web/"},{"name":"Nodejs","slug":"Web/Nodejs","permalink":"http://SungjuDoh.github.io/categories/Web/Nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://SungjuDoh.github.io/tags/nodejs/"},{"name":"web","slug":"web","permalink":"http://SungjuDoh.github.io/tags/web/"}]},{"title":"참조형 매개변수와 잠조형 반환타입","slug":"java_2","date":"2018-09-09T15:40:16.775Z","updated":"2018-09-10T11:18:45.401Z","comments":true,"path":"2018/09/10/java_2/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/10/java_2/","excerpt":"","text":"기본형 매개변수 (Primitive Type) : 가본형 값이 복사되는 것, Read only 참조형 매개변수 (Reference Type) : 인스턴스의 주소가 복사되는 것, Read &amp; Write 123456789class ReferenceParmEx&#123; pulic static void main(String[] args)&#123; int[] x = &#123;10&#125;; int[][] y = new int[][] &#123;&#123;55, 60, 65&#125;, &#123;85, 90, 95&#125;&#125;; &#125; static void change(int[] x, int[][] y)&#123; ... &#125;&#125; 예시 코드와 같이 배열을 매개변수로 넘길 때 사용할 수 있다. 참조형 반환타입 : 인스턴스의 주소가 반환되는 것 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class MatraixMult&#123; static int n; static int[][] a,b; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); n = input.nextInt(); a = new int[n][n]; b = new int[n][n]; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) a[i][j] = input.nextInt(); &#125; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) b[i][j] = input.nextInt(); &#125; int[][] ans = mult(a,b,n); for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) System.out.print(ans[i][j]+\" \"); System.out.println(); &#125; &#125; static int[][] mult(int[][] a, int[][] b, int n)&#123; int[][] ans = new int[n][n]; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; for(int k=0; k&lt;n; k++) ans[i][j] += a[i][k]*b[k][j]; &#125; &#125; return ans; &#125;&#125; 예시코드와 같이 행렬곱의 결과를 구하는 함수에서 다차원 배열을 반환할 수도 있다. 또한, 배열이나 인스턴스를 활용하면 메서드가 둘 이상의 값을 반환하는 효과가 있다.","categories":[{"name":"기타","slug":"기타","permalink":"http://SungjuDoh.github.io/categories/기타/"},{"name":"java","slug":"기타/java","permalink":"http://SungjuDoh.github.io/categories/기타/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://SungjuDoh.github.io/tags/java/"},{"name":"참조형매개변수","slug":"참조형매개변수","permalink":"http://SungjuDoh.github.io/tags/참조형매개변수/"},{"name":"참조형반환타입","slug":"참조형반환타입","permalink":"http://SungjuDoh.github.io/tags/참조형반환타입/"},{"name":"참조변수","slug":"참조변수","permalink":"http://SungjuDoh.github.io/tags/참조변수/"}]},{"title":"클래스변수와 인스턴스변수","slug":"java_1","date":"2018-09-09T15:16:27.664Z","updated":"2018-09-09T15:40:08.089Z","comments":true,"path":"2018/09/10/java_1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/10/java_1/","excerpt":"","text":"class Card를 예시로 살펴보자. 1234567class Card &#123; String kind; // 무늬 int numbef; // 숫자 static int width = 100; // 폭 static int height = 250; // 높이&#125; 클래스변수 (static변수) 는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 가진다. 따라서 클래스명.클래스변수명으로 직접 사용이 가능하다. 인스턴스변수 는 인스턴스가 생성될 떄 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있다. Tip. 멤버변수(클랙스변수와 인스턴스변수) 와 배열의 초기화는 선택적이고, 지역변수 는 필수적으로 초기화해야한다.","categories":[{"name":"기타","slug":"기타","permalink":"http://SungjuDoh.github.io/categories/기타/"},{"name":"java","slug":"기타/java","permalink":"http://SungjuDoh.github.io/categories/기타/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://SungjuDoh.github.io/tags/java/"},{"name":"클래스변수","slug":"클래스변수","permalink":"http://SungjuDoh.github.io/tags/클래스변수/"},{"name":"인스턴스변수","slug":"인스턴스변수","permalink":"http://SungjuDoh.github.io/tags/인스턴스변수/"}]},{"title":"Lv.4","slug":"cryptozombies_4","date":"2018-09-09T09:57:08.266Z","updated":"2018-10-17T08:52:29.576Z","comments":true,"path":"2018/09/09/cryptozombies_4/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/09/cryptozombies_4/","excerpt":"","text":"Payable 함수제어자 접근 제어자 (Visibility Modifier) : 함수가 언제, 어디서 호출될 수 있는지 제어 private internal public external 상태 제어자 (Visibility Modifier) : 블록체인과 상호작용하는 방법 View : 어떤 데이터도 저장/변경되지 않음 pure : 어떤 데이터도 블록체인에 저장하지 않고, 데이터를 읽지도 않음 두 함수 모두 컨트랙트 외부에서 호출 시 가스 소모가 없다. 사용자 정의 제어자 Payable 제어자일반적인 웹 서버에서 API 함수를 실행할 때에는, 함수 호출을 통해서 US달러나 비트코인을 보낼 수 없다. 하지만 이더리움에서는 돈(ether), 데이터(Transaction Payload), 컨트랙트 코드 자체 모두가 이더리움 위에 존재하기 때문에, 함수를 실행하는 동시에 컨트랙트에 돈을 지불하는 것이 가능하다. 함수를 실행하기 위해 컨트랙트에 일정 금액을 지불하는 예시 코드를 살펴보자.payable 예시코드12345678contract OnlineStore &#123; function buySomething() external payable &#123; // 함수 실행에 0.001이더가 보내졌는지 확실히 하기 위해 확인: require(msg.value == 0.001 ether); // 이더가 보내졌다면, 함수를 호출한 자에게 디지털 아이템을 전달하기 위한 내용 구성 transferThing(msg.sender); &#125;&#125; msg.value는 컨트랙트로 이더가 얼마나 보내졌는 지 확인하는 방법이다.DApp 의 자바스크립트 프론트앤드인 web3.js 에서 다음과 같이 함수를 실행할 때 해당 payable 함수가 실행된다.1OnlineStore.buySomething(&#123;from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)&#125;) value 필드에서 얼마의 이더를 보낼 지 결정하게된다.참고.만약 함수가 payable로 표시되지 않았을때 이더를 보내려 하면, 함수에서 트랜잭션을 거부할 것이다. 출금하기컨트랙트로 이더를 보내면, 해당 컨트랙트의 이더리움 계좌에 이더가 저장된다. 컨트랙트에서 이더를 인출하는 함수를 작성할 수 있다.12345contract GetPaid is Ownable &#123; function withdraw() external onlyOwner &#123; owner.transfer(this.balance); &#125;&#125; Ownable 컨트랙트를 import 했다고 가정하고, owner와 onlyOwner를 사용하고 있다. transfer : 이더를 특정 주소로 전달할 수 있다. this.balance : 컨트랙트에 저장되어있는 전체 잔액을 반환한다. 누군가 한 아이템에 대해 초과 지불을 하면, 이더를 되돌려주는 함수도 만들 수 있다.12uint itemFee = 0.001 ether;msg.sender.transfer(msg.value - itemFee); 혹은 구매자와 판매자가 존재하는 컨트랙트에서, 누군가 판매자의 아이템을 구매하면 구매자로부터 받은 요금을 판매자에게 전달할 수 있다.1seller.transfer(msg.value); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152////zombiehelper.solpragma solidity ^0.4.19;import \"./zombiefeeding.sol\";contract ZombieHelper is ZombieFeeding &#123; //레벨 업을 위해 지불해야하는 비용 uint levelUpFee = 0.001 ether; modifier aboveLevel(uint _level, uint _zombieId) &#123; require(zombies[_zombieId].level &gt;= _level); _; &#125; //우리 컨트랙트의 이더리움 계좌에 저장된 이더를 인출하는 함수 function withdraw() external onlyOwner&#123; owner.transfer(this.balance); &#125; //현재는 0.001 ether로 지정되어 있는 levelUpFee를 변경하는 함수 function setLevelUpFee(uint _fee)external onlyOwner&#123; levelUpFee = _fee; &#125; //ether를 지불하여 levelup을 가능하게하는 함수 function levelUp(uint _zombieId) external payable &#123; require(msg.value == levelUpFee); zombies[_zombieId].level++; &#125; function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123; require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; &#125; function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123; require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; &#125; function getZombiesByOwner(address _owner) external view returns(uint[]) &#123; uint[] memory result = new uint[](ownerZombieCount[_owner]); uint counter = 0; for (uint i = 0; i &lt; zombies.length; i++) &#123; if (zombieToOwner[i] == _owner) &#123; result[counter] = i; counter++; &#125; &#125; return result; &#125;&#125; 난수솔리디티에서 난수를 만들기에 가장 좋은 방법을 keccak256 해시 함수를 쓰는 것이다.1uint random = uint(keccak256(now, msg.sender, randNonce)) % 100; now의 타임스탬프 값, msg.sender, 증가하는 nounce를 받고 있다. nonce는 딱 한 번만 사용되는 숫자로 똑같은 입력으로 두 번 이상 동일한 해시함수를 실행할 수 없게 한다. %100 을 통해 마지막 2자리 숫자만 받고, 이를 통해 0과 99사이의 완전한 난수를 얻을 수 있다. 하지만 이 메소드는 정직하지 않은 노드의 공격에 취약하다. 이더리움에서는 컨트랙트의 함수를 실행하면 트랜잭션(transaction) 으로서 네트워크의 노드 하나 혹은 여러 노드에 실행을 알린다. 그 후 네트워크의 노드들은 여러 트랜잭션을 모으고. 작업증명(PoW) 이라는 매우 복잡한 수학적 문제를 풀기 위한 시도를 한다. 그리고 블럭(해당 트랜잭션 그룹 + 작업증명) 으로 네트워크에 배포한다. 한 노드가 어떤 PoW를 풀면, 다른 노드들은 그 PoW를 풀려는 시도를 멈추고, 해당 노드가 보낸 트랜잭션 목록이 유효한 것인지 검증한다. 유효하다면 해당 블록을 받아들이고 다음 블록 을 풀기 시작한다. 이 과정이 우리의 난수 함수를 취약하게 만든다. 내가 만약 노드를 실행하고 있다면, 나는 오직 나의 노드에만 트랜잭션을 알리고 이것을 공유하지 않을 수 있다. 그 후 함수를 실행하고, 유리하지 않은 결과가 나오면, 내가 풀고 있는 다음 블록에 해당 트랜잭션을 포함하지 않는 것 을 선택한다. 원하는 결과를 얻을 때까지 무한대로 반복할 수 있고, 이득을 볼 수 있다. 이더리움에서 난수를 안전하게 만드는 한 가지 방법은 외부의 난수 함수에 접근할 수 있도록 오라클 (이더리움 외부에서 데이터를 받아오는 안전한 방법 중 하나)을 사용하는 것이다. @@나중에 더채우기1234567891011121314151617181920//zombieattack.solimport \"./zombiehelper.sol\";contract ZombieBattle is ZombieHelper &#123; uint randNonce = 0; //공격하는 좀비라면 승률 70% uint attackVictoryProbability = 70; //난수를 생성하는 함수 function randMod(uint _modulus) internal returns(uint) &#123; randNonce++; //매번 증가해서 같은 입력으로 동일한 해시함수를 두 번 이상 실행하지 않음 return uint(keccak256(now, msg.sender, randNonce)) % _modulus; &#125; // 공격하는 함수 function attack(uint _zombieId, uint _targetId) external&#123; &#125;&#125; 공통 로직 구조 개선하기web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.3","slug":"cryptozombies_3","date":"2018-09-08T05:44:31.511Z","updated":"2018-10-09T04:53:12.312Z","comments":true,"path":"2018/09/08/cryptozombies_3/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/08/cryptozombies_3/","excerpt":"","text":"컨트랙트의 불변성이더리움 DApp의 다른 애플리캐이션과는 다른 특징 Immutable 컨트랙트 배포 후, 컨트랙트를 수정하거나 업데이트 불가하다. 컨트랙트로 배포한 최초의 코드는 항상 블록체인에 영구적으로 존재한다. 코드가 곧 법인이 되는 격. 어떤 컨트랙트의 코드를 읽고 검증했다면 이후에 그 누구도 함수를 수정하거나 예상치 못한 결과를 발생시키지 못한다. 외부 의존성따라서, 대개의 경우 DApp의 중요한 일부를 수정 할 수 있도록 하는 함수 를 만들어놓는 것이 합리적이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; KittyInterface kittyContract; //크립토키티 컨트랙트 주소를 업데이트 가능하게 하는 메소드 추가 //참고) external 이라서 누구나 크립토키티 컨트렉트의 주소를 바꿀 수 있는 취약점 function setKittyContractAddress(address _address) external &#123; kittyContract = KittyInterface(_address); &#125; function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; 소유 가능한 컨트랙트모든 사람이 우리의 컨트랙트를 업데이트할 수 없도록, 컨트랙트를 대상으로 특별한 권리를 가지는 소유자가 있음을 의미한다. OpenZeppelin 솔리디티 라이브에서 가져온 Ownable 컨트랙트Ownable 컨트랙트1234567891011121314151617181920212223242526272829303132333435/** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */contract Ownable &#123; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public &#123; owner = msg.sender; &#125; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; &#125;&#125; 컨트랙트가 생성되면 owner에 컨트랙트를 배포한 사람 을 대입한다. 특정 함수들에 대해 오직 소유자만 접근 할 수 있도록 제한한다. 새로운 소유자에게 해당 컨트랙트의 소유권을 옮길 수 있도록 한다. onlyOwner 제어자를 함수에 추가하면, 오직 컨트렉트 소유자 만 해당 함수 호출이 가능하다. 대부분의 솔리디티 DApp들은 Ownable컨트랙트를 복사/붙여넣기 하면서 시작한다. 그리고 첫 컨트랙트는 이 컨트랙트를 상속하여 만든다. 참고 생성자(Constructor) : 컨트랙트가 생성될 때 딱 한 번만 실행된다. 컨트랙트와 동일 이름을 가진다. 함수 제어자(Function Modifier) : 다른 함수들에 대한 접근을 제어하기 위한 일종의 유사 함수다. 보통 함수 실행 전의 요구사항 충족 여부를 확인하는 데에 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445pragma solidity ^0.4.19;//import Ownable.solimport \"./Ownable.sol\";//Ownable 컨트렉트를 상속한다.//이로써, ZombieFactory를 상속하는 ZombieFeeding 도 ownable 해진다.//상속관계: ZombieFeeding -&gt; ZombieFactory -&gt; Ownablecontract ZombieFactory is Ownable&#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) internal &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; KittyInterface kittyContract; //해당 함수에 onlyOwner 제어자 추가 //해당 함수 호출 시, onlyOwner 코드 먼저 실행 //onlyOwner의 _; 부분에서 해당 함수로 되돌아와서 코드 실행 //이로써 컨트랙트 소유자만 해당 함수를 호출할 수 있게돼고, 더이상 아무나 크립토키티의 주소를 바꿀 수 없다. function setKittyContractAddress(address _address) external onlyOwner&#123; kittyContract = KittyInterface(_address); &#125; function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; 가스(Gas)“이더리움 DApp이 사용하는 연료” 솔리디티에서는 사용자들이 DApp의 함수를 실행할 때마다 가스 라는 화폐를 지불해야한다. 사용자는 이더(ETH, 이더리움 화폐) 를 이용해서 가스를 사기 때문에, DApp 함수를 실행하려면 사용자들은 ETH 를 소모해야한다. 함수를 실행하는 데에 필요한 가스량은 그 함수의 로직 이 얼마나 복잡한지에 따라 달라진다. 1. 가스 비용(gas cost)각 연산은 소모되는 가스비용을 가지고, 해당 연산 수행에 소모되는 컴퓨팅 자원의 양이 이 비용을 결정한다.예를 들어, storage에 값을 쓰는 것 &gt; 두 정수를 더하는 것 이더리움에서 코드 최적화는 다른 프로그래밍 언더들에 비해 훨씬 중요하다. 코드가 엉망이라면, 사용자들은 함수를 실행하기 위해 일종의 할증료를 더 내야하기 때문이다. 2. 가스는 왜 필요한가?이더리움은 크고 느리지만 굉장히 안전한 컴퓨터와 같다.어떤 함수를 실행할 때, 네트워크상의 모든 개별 노드가 함수의 출력값을 검증하기 위해 그 함수를 실행해야 한다. 모든 함수의 실행을 검증하는 수천 개의 노드 가 이더리움을 분산화하고, 데이터를 보존하며 누군가 검열할 수 없도록 하는 요소이다. 이더리움을 만든 사람들은 누군가가 무한 반복문을 써서 네트워크를 방해하거나, 자원 소모가 큰 연산으로 네트워크 자원을 모두 사용하지 못하도록 만들길 원했다. 그래서 연산 처리에 비용이 들도록 만들었고, 사용자들은 저장 공간과 연산 사용 시간 에 따라서 비용을 지불해야 한다. 참고: 다른 합의 알고리즘을 가진 사이드체인 에서는 반드시 이렇지는 않다. 따라서 DApp을 사이드체인과 이더리움 메인넷 중 어디에 올릴 지 판단하는 방법들도 추후에 배우게 된다. 3. 가스를 아끼기 위한 구조체 압축uint는 크기에 상관없이 256비트의 저장 공간을 미리 잡아 놓는다.하지만 struct 안에서는 변수들을 더 적은 공간을 차지하도록 압축할 것이므로, 가능한 더 작은 크기의 uint를 쓰는 것이 좋다.또한, 동일한 데이터 타입은 하나로 묶어놓는 것이 좋다.uint c; uint32 a; uint32 b; 의 경우, uint32 필드가 묶여있다. zombiefactory.sol의 Zombie struct를 uint32 필드가 묶일 수 있도록 붙여서 data를 추가했다.123456struct Zombie &#123; string name; uint dna; uint32 level; uint32 readyTime; &#125; 시간 단위솔리디티는 시간을 다룰 수 있는 단위계를 기본적으로 제공한다. now 변수를 사용하면 현재의 유닉스 타임스탬프(1970.01.01부터 지금까지의 초 단위 합)값을 얻을 수 있다. 참고유닉스 타임은 전통적으로 32비트 숫자로 저장된다. 따라서 2038년 부터 문제를 일으킬 것이므로, 20년 이상 운영되길 원한다면 64비트 숫자를 써야하고, 이때 가스 비용 또한 고려해야한다. 솔리디티는 또한 seconds, minutes, hours, days, weeks, years 같은 시간 단위 를 포함한다. 이들은 그에 해당하는 길이 만큼의 초 단위 uint 숫자로 변환된다. 1 hours와 같이 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//zombiefactory.solpragma solidity ^0.4.19;import \"./ownable.sol\";contract ZombieFactory is Ownable &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; //하루로 cooldownTime 초기화 uint cooldownTime = 1 days; struct Zombie &#123; string name; uint dna; uint32 level; uint32 readyTime; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) internal &#123; //update된 Zombie struct에 맞도록 level과 readyTime을 push 해준다. //이때, now는 uint256을 반환해서 uint32()를 표기해야한다. uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now+cooldownTime))) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); randDna = randDna - randDna % 100; _createZombie(_name, randDna); &#125;&#125; 구조체를 인수로 전달private 또는 internal 함수에 인수로서 구조체의 storage 포인터 를 전달할 수 있다. 구조체 인수 전달 예시코드12function _doStuff(Zombie storage _zombie) internal &#123;&#125; // 여기서 Zombie 는 구조체명 Public 함수와 보안public과 external 함수는 특수한 제어자를 갖지 않는 이상, 어떤 사용자든 이 함수들을 호출하고 자신들이 원하는 모든 데이터를 함수에 전달할 수 있다.따라서 보안 점검을 위해 이 함수들을 검사하고, 사용자들이 이들을 남용할 수 있는 방법을 생각해봐야한다. 함수를 internal로 만드는 것도 한 가지 예다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; KittyInterface kittyContract; function setKittyContractAddress(address _address) external onlyOwner &#123; kittyContract = KittyInterface(_address); &#125; //Zombie 구조체를 인자로 가지는 두 메소드 정의 function _triggerCooldown(Zombie storage _zombie) internal &#123; _zombie.readyTime = uint32(now + cooldownTime); &#125; function _isReady(Zombie storage _zombie) internal view returns (bool) &#123; return (_zombie.readyTime &lt;= now); &#125; //해당 함수를 internal로 바꿔서, 누구나 feed 할 수 없도록 함 function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; //myZombie가 준비가되면 이하 코드 실행 require(_isReady(myZombie)); _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); //myZombie가 cooldown할 시간을 갖도록 함 _triggerCooldown(myZombie); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; 인수를 가지는 함수 제어자예시코드123456789101112// 사용자의 나이를 저장하기 위한 매핑mapping (uint =&gt; uint) public age;// 사용자가 특정 나이 이상인지 확인하는 제어자modifier olderThan(uint _age, uint _userId) &#123; require (age[_userId] &gt;= _age); _;&#125;// `olderThan` 제어자를 인수와 함께 호출function driveCar(uint _userId) public olderThan(16, _userId) &#123;&#125; View 함수를 사용해 가스 절약하기view 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않는다. 이는 view함수가 블록체인 상에서 실제로 어떤 것도 수정하지 않고 데이터를 읽기만 하기 때문이다. 이 함수는 실행할 때 로컬 이더리움 노드 에 질의만 하고, 블록체인에 어떤 트랜잭션도 만들지 않는다. 트랜잭션 : 모든 개별 노드에서 실행되어야 하고, 가스를 소모한다. 따라서, 가스 사용을 최적화하는 비결은 가능한 모든 곳에 읽기 전용 의 external view 함수를 쓰는 것이다. 참고view함수가 동일 컨트랙트 내에 있는 다른 함수에서 내부적 으로 호출되는 경우에는 가스가 소모된다. 다른 함수가 이더리움에 트랜잭션 을 생성하기 때문이다. 메모리에 배열 선언하기storage데이터를 사용하는 것은 비싼 연산이다. (특히 쓰기 연산) 해당 데이터를 쓰거나 바꿀 때마다 수천 개의 노드들이 그들의 하드 드라이브에 데이터를 저장해야하기 때문이다. 비용을 최소화 하기위해, 정말 필요한 경우가 아니면 storage데이터를 사용하지 않는 것이 좋다. 이를 위해 때때로는 겉보기에 비효율적으로 보이는 프로그래밍 구성이 필요하다. 어떤 배열에서 내용을 빠르게 찾기 위해, 단순히 변수에 저장하는 것 대신 함수가 호출될 때마다 배열을 memory에 다시 만드는 것 이 한 가지 예시이다. uint[] memory values = new uint[](3);memory 키워드를 사용하면 되고, 반드시 길이 인수 와 함께 생성되어야 한다. 이 배열은 함수가 끝날 때까지만 존재할 것이고, 만약 이 함수가 외부에서 호출되는 view함수라면 비용은 무료이다. For 반복문때때로 함수 내에서 배열을 다룰 때, storage에 해당 배열을 저장하지 않고 for반복문을 사용해서 구성해야 할 필요가 있다. 우리 코드를 예시로 생각해보자.getZombiesByOwner 함수를 구현할 때, 가장 기초적인 구현 방법은 ZombieFactory컨트랙트에서 소유자의 좀비군대에 대한 mapping을 만들어서 저장하는 것이다.mapping (address =&gt; uint[]) public ownerToZombies; 이후에 새로운 좀비를 만들 때마다, 해당 소유자의 좀비 배열에 추가하는 것이다.ownerToZombies[owner].push(zombieId);이렇게 되면 getZombiesByOwner 함수는 다음과 같이 아주 이해하기 쉬운 함수가 된다.123function getZombiesByOwner(address _owner) external view returns (uint[]) &#123; return ownerToZombies[_owner];&#125; 이 방식의 문제점만약 나중에 한 좀비를 원래 소유자에서 다른 사람에게 전달하는 함수를 구현하게 되면 문제가 생긴다. 기존 소유자의 좀비 배열에서 해당 좀비를 지운 후, 좀비가 지워진 구멍을 메우기 위해 기존 소유자의 배열에서 모든 좀비를 한 칸씩 움직여서 배열의 길이를 지워야한다. storage 연산의 가스 비용이 아주 높고, 함수가 실행될 때마다 다른 양의 가스가 소모되기 때문에 이를 예측할 수 도 없다. Solutionview 함수는 외부 호출 시 가스를 소모하지 않기 때문에, for반복문을 사용하여 좀비 배열의 모든 요소에 접근하여 특정 사용자의 좀비들로 구성된 배열 을 만들 수 있을 것이다. 이렇게 되면 transfer 함수는 훨씬 비용을 적게 쓰게된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//zombiehelper.solpragma solidity ^0.4.19;import \"./zombiefeeding.sol\";contract ZombieHelper is ZombieFeeding &#123; //인자를 가지는 함수 제어자 //기준 _level 이상인 지 확인하는 제어자 modifier aboveLevel(uint _level, uint _zombieId) &#123; require(zombies[_zombieId].level &gt;= _level); _; &#125; //zombie의 이름을 바꾸는 함수 function changeName(uint _zombieId, string _newName) external aboveLevel(2, _zombieId) &#123; require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].name = _newName; &#125; //zombie의 dna를 바꾸는 함수 function changeDna(uint _zombieId, uint _newDna) external aboveLevel(20, _zombieId) &#123; require(msg.sender == zombieToOwner[_zombieId]); zombies[_zombieId].dna = _newDna; &#125; //사용자의 전체 좀비군대를 반환하는 함수 //추후에, 만약 사용자들의 프로필 페이지에 그들의 전체 군대를 표시하고 싶다면, 이 함수를 web3.js에서 호출하면 된다. //view 함수 : gas 소비 없음 function getZombiesByOwner(address _owner) external view returns(uint[]) &#123; //ownerZombieCount Mapping을 이용하여 사용자가 가진 모든 좀비 개 찾음. //result: 사용자의 모든 좀비를 담을 배열 uint[] memory result = new uint[](ownerZombieCount[_owner]); //result index 추적 uint counter = 0; //for 반복문을 통해 우리 DApp 안에 있는 모든 좀비들에 접근하고, //그들의 소유자가 _owner인지 비교하여 확인한 후, //조건에 맞는 좀비들을 result 배열에 추가한 후 반환 for(uint i=0; i&lt;zombies.length; i++)&#123; if(zombieToOwner[i] == _owner)&#123; //_owner과 일치하면 좀비 id 추가 result[counter] = i; counter++; &#125; &#125; return result; &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.2","slug":"cryptozombies_2","date":"2018-09-07T12:15:36.396Z","updated":"2018-09-08T05:17:59.904Z","comments":true,"path":"2018/09/07/cryptozombies_2/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/07/cryptozombies_2/","excerpt":"","text":"주소와 매핑데이터베이스에 저장된 좀비들에게 주인을 설정하여 멀티 플레이어 게임으로 만든다.mapping과 address 두 자료형이 필요하다. 주소이더리움 블록체인은 은행 계좌와 같은 계정 들로 이뤄져있다. 계정은 이더리움 블록체인상의 통화인 이더 의 잔액을 가진다. 계정을 통해 다른 계정과 이더를 주고 받을 수 있다. 각 계정은 은행 계쫘 번호와 같은 주소 를 가지고 있다. 주소는 특정 계정을 가리키는 고유 식별자이다. “ 주소는 특정 유저(혹은 스마트 컨트랙트)가 소유한다. “ 매핑솔리디티에서 구조화된 데이터를 저장하는 또다른 방법이다. 다음과 같이 매핑을 정의할 수 있다.mapping (address =&gt; uint) public accountaBallance; 매핑은 기본적으로 key-value 저장소로, 데이터를 저장하고 검색하는 데 이용된다.key =&gt; value 12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; // 좀비 id =&gt; 좀비 소유자 주소 mapping (address =&gt; uint) ownerZombieCount; // 좀비 소유자 주소 =&gt; 좀비 수 function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; msg.sender솔리디티에는 모든 함수에서 이용 가능한 특정 전역 변수 들이 있다. Msg.sender : 현재 함수를 호출한 사람(혹은 스마트 컨트랙트)의 주소(address)를 가리키는 변수 Tip. 솔리디티에서 함수 실행은 항상 외부 호출자가 한다. 따라서 항상 msg.sender의 값은 존재한다. 컨트랙트는 누군가가 컨트랙트의 함수를 호출할 때까지 블록체인 상에서 아무 것도 하지 않는다. msg.sender를 활용하면, 이더리움 블록체인의 보안성을 이용할 수 있다. 누군가 다른 사람의 데이터를 변경하려면 해당 이더리움 주소와 관련된 개인키를 훔치는 방법 뿐이다. require특정 조건이 참이 아닐 때 함수가 에러 메시지를 발생하고 실행을 멈춘다. 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; // 새로운 좀비의 id zombieToOwner[id] = msg.sender; // 좀비 id =&gt; 좀비 소유자 주소 ownerZombieCount[msg.sender]++; // 좀비 소유자가 가진 좀비 수 증가 NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); // 유저가 군대에 좀비를 무제한으로 생성하는 것을 방지 uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; 상속상속 예시코드1234567891011contract Doge &#123; function catchphrase() public returns (string) &#123; return \"So Wow CryptoDoge\"; &#125;&#125;contract BabyDoge is Doge &#123; function anotherCatchphrase() public returns (string) &#123; return \"Such Moon BabyDoge\"; &#125;&#125; 위 코드에서 BabyDoge 컨트랙트는 Doge 컨트랙트를 상속한다.BabyDoge가 컴파일되어 구축될 때, Doge 컨트랙트에 정의되는 어떤 public 함수에도 접근이 가능하다. 보통 부분집합 관계에서 상속 이 사용된다. Import다수의 파일이 있고, 어떤 파일을 다른 파일로 불러오고 싶을 때 사용한다.import &quot;./someothercontract.sol&quot;; 코드가 길어져서 여러 파일로 나누어 정리하고, import라는 키워드로 다른 파일을 불러온다. 1234567//zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\"; // importcontract ZombieFeeding is ZombieFactory &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//zombiefactory.solpragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; Storage &amp; Memory솔리디티에서 변수를 저장할 수 있는 공간 Storage블록체인 상에 영구적으로 저장되는 변수컴퓨터의 하드 디스크와 비슷하다. Memory임시적으로 저장되는 변수로, 컨트랙트 함수에 대한 외부 호출들이 일어나는 사이에 지워진다.컴퓨터의 RAM과 비슷하다. 대부분의 경우, 이런 키워드를 사용할 필요가 없다.솔리디티에서 자동으로 상태변수(함수 외부에 선언된 변수) : storage 로 선언되어, 영구적으로 저장 함수 내에 선언된 변수 : memory 로 선언되어, 함수 호출이 종료되면 사라짐 하지만 키워드가 필요한 경우가 있다. 구조체와 배열키워드 사용 코드예시123456789101112131415161718192021222324contract SandwichFactory &#123; struct Sandwich &#123; string name; string status; &#125; // 구조체 Sandwich[] sandwiches; // 구조체 배열 function eatSandwich(uint _index) public &#123; Sandwich storage mySandwich = sandwiches[_index]; // `sandwiches[_index]`를 가리키는 포인터 mySandwich.status = \"Eaten!\"; // 따라서 `sandwiches[_index]`을 영구적으로 변경 Sandwich memory anotherSandwich = sandwiches[_index + 1]; // `anotherSandwich`는 단순히 메모리에 데이터를 복사 anotherSandwich.status = \"Eaten!\"; // 임시 변수인 `anotherSandwich`를 변경 // `sandwiches[_index + 1]`에는 아무런 영향을 끼치지 않음 sandwiches[_index + 1] = anotherSandwich; // 다른 활용 방안 : 임시 변경한 내용을 블록체인 저장소에 저장 &#125;&#125; 함수 접근 제어자 public모든 컨트랙트에서 사용 가능 private함수가 정의된 컨트랙트에서만 사용 가능 internal함수가 정의된 컨트랙트와 이를 상속하는 컨트랙트에서도 사용 가능 external컨트랙트 바깥에서만 호출될 수 있고, 컨트랙트 내의 다른 함수에서는 사용 불가.나머지는 public 과 동일 interface블록체인 상에 있으면서 소유하지 않은 컨트랙트와 상호작용을 하려면 우선 interface 를 정의해야 한다. interface 정의 예시코드123contract NumberInterface &#123; function getNum(address _myAddress) public view returns (uint);&#125; dapp 코드에 이런 interface 를 포함하면 컨트랙트는 다른 컨트랙트에 정의된 함수의 특성, 호출 방법, 리턴 값에 대해 알 수 있다. interface 활용하기interface 를 이용하여, 이더리움 블록체인 상의 다른 어떤 컨트랙트와도 상호작용할 수 있다. 이 때, 상호작용하는 함수가 public이나 external로 선언되어 있어야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.19;//zombiefeeding.solimport \"./zombiefactory.sol\";// 크립토좀비가 가장 좋아하는 먹이, 크립토키티와 상호작용할 수 있게하는 KittyInterface 정의contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; // 크립토키티 컨트렉트 주소 KittyInterface kittyContract = KittyInterface(ckAddress); // 크립토키티 인터페이스 생성 및 초기화 // KittyContract가 해당 주소 컨트랙트를 가리킴 function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123; require(msg.sender == zombieToOwner[_zombieId]); // 좀비 주인만 먹이를 줄 수 있도록 Zombie storage myZombie = zombies[_zombieId]; // Zombie 구조체 변수를 storage로 선언, 영구 저장 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; _createZombie(\"NoName\", newDna); // _createZombie 함수는 ZombieFactory 컨트랙트의 internal 함수 &#125;&#125; 다수의 반환값 처리123function multipleReturns() internal returns(uint a, uint b, uint c) &#123; return (1, 2, 3);&#125; 다음과 같이 3개의 값을 반환하는 함수가 있다.이러한 다수의 반환값을 활용하는 방안에는 다수 값 할당 123456function processMultipleReturns() external &#123; uint a; uint b; uint c; (a, b, c) = multipleReturns();&#125; 단 하나의 값에만 관심이 있는 경우 12345function getLastReturnValue() external &#123; uint c; (,,c) = multipleReturns(); // 다른 필드는 빈칸으로 놓으면 됨&#125; 등이 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; // 만약 kitty 라면, DNA 마지막 두 자리로 99 가짐 if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); // 다수의 반환값 중 마지막 반환값에만 관심 // interface를 통해 getkitty 함수 접근 feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.1","slug":"cryptozombies_1","date":"2018-09-04T11:02:50.633Z","updated":"2018-09-07T12:09:12.289Z","comments":true,"path":"2018/09/04/cryptozombies_1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/04/cryptozombies_1/","excerpt":"","text":"컨트랙트이더리움 애플리케이션의 기본적인 구성 요소 (모든 변수/함수 는 어느 한 컨트랙트에 속함)모든 솔리디티 소스 코드는 해당 코드가 이용해야 하는 솔리디티 버전을 선언하며 시작한다. 상태변수컨트랙트 저장소에 영구적으로 저장된다.a.k.a. 이더리움 블록체인에 기록되는 것으로 데이터베이스에 데이터를 쓰는 것과 동일하다. 정수 uint(부호 없는 정수, &gt;= 0) int(부호 있는 정수 실제로 uint는 uint256를 의미한다. (256비트의 부호 없는 정수)uint8, uint16, uint32 등 도 있다. 수학 연산 덧셈 : x + y 뺄셈 : x - y 곱셈 : x * y 나눗셈 : x / y 모듈러 (나머지) : x % y 지수연산 (x의 y제곱) : x ** y 12345678pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; // 좀비 DNA: 16자리 uint dnaModulus = 10 ** dnaDigits; // 16자리보다 큰 수를 16자리 숫자로 줄임&#125; 구조체여러 특성을 가진 자료형을 생성할 수 있다.참고) string: 임의의 길이를 가진 UTF-8 데이터 배열 정적 배열uint[2] fixedArray; 동적 배열uint[] dynamicArray; tip.구조체 배열도 생성 가능하다.상태 변수는 컨트랙트 저장소에 영구적으로 저장되므로,구조체 동적 배열은 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는 데 유용하다. public으로 배열 선언 시 getter 메소드가 자동적으로 생성 되어,다른 컨트랙트들이 이 배열을 읽을 수 있게되므로 (read only), 컨트랙트에 공개 데이터를 저장할 때 유용하다. 123456789101112131415pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; // 좀비의 특성을 멤버로 가지는 구조체 Zombie[] public zombies; // public 좀비 군대 저장소&#125; 함수 선언tip.관례적으로 함수 인자명을 언더바(_)로 시작해서 전역 변수와 구별한다. 구조체 생성새로운 구조체를 생성하고, 이를 구조체 배열에 추가할 수 있다. Private/ Public 함수함수는 기본적으로 public으로 선언된다. 이는 누구나 해당 함수를 호출 및 실행할 수 있음을 의미한다.따라서 보통의 경우 private으로 함수를 선언하는 것이 바람직하다. 이는 동일 컨트랙트 내의 다른 함수들만이 이 함수를 호출할 수 있음을 의미한다. 관례적으로 private 함수명은 언더바(_)로 시작한다. 반환값반환값의 자료형을 포함한다.function sayHello() public view returns (string) { 함수 제어자함수 제어자 예시코드123function _multiply(uint a, uint b) private pure returns (uint) &#123; return a * b;&#125; view: 상태를 변화시키지 않는 함수 (a.k.a. 어떤 값을 변경하지 않음) pure: 앱에서 어떤 데이터도 접근하지 않는 함수 (ex. 앱에서 읽는 것도 없이, 반환값이 함수에 전달된 인자값에 따라 달라지는 함수) Keccak256이더리움은 내장 해시 함수로 SHA3의 한 버전인 keccak256를 가진다. 해 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑한다. 참고: 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제다. 형 변환형 변환 예시코드1234uint8 a = 5;uint b = 6;uint8 c = a * b; // a * b가 uint8이 아닌 uint를 반환하기 때문에 에러uint8 c = a * uint8(b); // 256비트 =&gt; 8비트 형 변환 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; zombies.push(Zombie(_name, _dna)); &#125; // 좀비 생성하여 좀비군대 배열에 push하는 함수 function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; // string으로 부터 랜덤 DNA를 생성하는 함수 function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125; // 좀비의 이름을 입력값으로 받아 랜덤 DNA를 가진 좀비를 만드는 함수&#125; 이벤트컨트랙트가 블록체인 상의 앱 사용자 단에서 어떤 액션이 발생했을 때 의사소통하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는 지 귀 기울이고, 그 이벤트가 발생하면 행동을 취한다. 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); // 좀비가 생성될 때 마다 앱의 사용자 단에서 이를 알고, 표시하도록하는 이벤트 uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); // 새로운 좀비가 배열에 추가된 후에 이벤트 실행 &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-02T07:15:23.646Z","updated":"2018-09-10T11:19:32.956Z","comments":true,"path":"2018/09/02/hello-world/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
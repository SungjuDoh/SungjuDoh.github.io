{"meta":{"title":"://Sungju.github.io","subtitle":"dev diary","description":null,"author":"Sungju Doh","url":"http://SungjuDoh.github.io"},"pages":[],"posts":[{"title":"Lv.2","slug":"cryptozombies_2","date":"2018-09-07T12:15:36.396Z","updated":"2018-09-08T05:03:31.681Z","comments":true,"path":"2018/09/07/cryptozombies_2/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/07/cryptozombies_2/","excerpt":"","text":"주소와 매핑데이터베이스에 저장된 좀비들에게 주인을 설정하여 멀티 플레이어 게임으로 만든다.mapping과 address 두 자료형이 필요하다. 주소이더리움 블록체인은 은행 계좌와 같은 계정 들로 이뤄져있다. 계정은 이더리움 블록체인상의 통화인 이더 의 잔액을 가진다. 계정을 통해 다른 계정과 이더를 주고 받을 수 있다. 각 계정은 은행 계쫘 번호와 같은 주소 를 가지고 있다. 주소는 특정 계정을 가리키는 고유 식별자이다. “ 주소는 특정 유저(혹은 스마트 컨트랙트)가 소유한다. “ 매핑솔리디티에서 구조화된 데이터를 저장하는 또다른 방법이다. 다음과 같이 매핑을 정의할 수 있다.mapping (address =&gt; uint) public accountaBallance 매핑은 기본적으로 key-value 저장소로, 데이터를 저장하고 검색하는 데 이용된다.key =&gt; value 12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; // 좀비 id =&gt; 좀비 소유자 주소 mapping (address =&gt; uint) ownerZombieCount; // 좀비 소유자 주소 =&gt; 좀비 수 function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; msg.sender솔리디티에는 모든 함수에서 이용 가능한 특정 전역 변수 들이 있다. Msg.sender : 현재 함수를 호출한 사람(혹은 스마트 컨트랙트)의 주소(address)를 가리키는 변수 Tip. 솔리디티에서 함수 실행은 항상 외부 호출자가 한다. 따라서 항상 msg.sender의 값은 존재한다. 컨트랙트는 누군가가 컨트랙트의 함수를 호출할 때까지 블록체인 상에서 아무 것도 하지 않는다. msg.sender를 활용하면, 이더리움 블록체인의 보안성을 이용할 수 있다. 누군가 다른 사람의 데이터를 변경하려면 해당 이더리움 주소와 관련된 개인키를 훔치는 방법 뿐이다. require특정 조건이 참이 아닐 때 함수가 에러 메시지를 발생하고 실행을 멈춘다. 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; // 새로운 좀비의 id zombieToOwner[id] = msg.sender; // 좀비 id =&gt; 좀비 소유자 주소 ownerZombieCount[msg.sender]++; // 좀비 소유자가 가진 좀비 수 증가 NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); // 유저가 군대에 좀비를 무제한으로 생성하는 것을 방지 uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; 상속상속 예시코드1234567891011contract Doge &#123; function catchphrase() public returns (string) &#123; return \"So Wow CryptoDoge\"; &#125;&#125;contract BabyDoge is Doge &#123; function anotherCatchphrase() public returns (string) &#123; return \"Such Moon BabyDoge\"; &#125;&#125; 위 코드에서 BabyDoge 컨트랙트는 Doge 컨트랙트를 상속한다.BabyDoge가 컴파일되어 구축될 때, Doge 컨트랙트에 정의되는 어떤 public 함수에도 접근이 가능하다. 보통 부분집합 관계에서 상속 이 사용된다. Import다수의 파일이 있고, 어떤 파일을 다른 파일로 불러오고 싶을 때 사용한다.import &quot;./someothercontract.sol&quot;; 코드가 길어져서 여러 파일로 나누어 정리하고, import라는 키워드로 다른 파일을 불러온다. 1234567//zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\"; // importcontract ZombieFeeding is ZombieFactory &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//zombiefactory.solpragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; Storage &amp; Memory솔리디티에서 변수를 저장할 수 있는 공간 Storage블록체인 상에 영구적으로 저장되는 변수컴퓨터의 하드 디스크와 비슷하다. Memory임시적으로 저장되는 변수로, 컨트랙트 함수에 대한 외부 호출들이 일어나는 사이에 지워진다.컴퓨터의 RAM과 비슷하다. 대부분의 경우, 이런 키워드를 사용할 필요가 없다.솔리디티에서 자동으로 상태변수(함수 외부에 선언된 변수) : storage 로 선언되어, 영구적으로 저장 함수 내에 선언된 변수 : memory 로 선언되어, 함수 호출이 종료되면 사라짐 하지만 키워드가 필요한 경우가 있다. 구조체와 배열키워드 사용 코드예시123456789101112131415161718192021222324contract SandwichFactory &#123; struct Sandwich &#123; string name; string status; &#125; // 구조체 Sandwich[] sandwiches; // 구조체 배열 function eatSandwich(uint _index) public &#123; Sandwich storage mySandwich = sandwiches[_index]; // `sandwiches[_index]`를 가리키는 포인터 mySandwich.status = \"Eaten!\"; // 따라서 `sandwiches[_index]`을 영구적으로 변경 Sandwich memory anotherSandwich = sandwiches[_index + 1]; // `anotherSandwich`는 단순히 메모리에 데이터를 복사 anotherSandwich.status = \"Eaten!\"; // 임시 변수인 `anotherSandwich`를 변경 // `sandwiches[_index + 1]`에는 아무런 영향을 끼치지 않음 sandwiches[_index + 1] = anotherSandwich; // 다른 활용 방안 : 임시 변경한 내용을 블록체인 저장소에 저장 &#125;&#125; 함수 접근 제어자 public모든 컨트랙트에서 사용 가능 private함수가 정의된 컨트랙트에서만 사용 가능 internal함수가 정의된 컨트랙트와 이를 상속하는 컨트랙트에서도 사용 가능 external컨트랙트 바깥에서만 호출될 수 있고, 컨트랙트 내의 다른 함수에서는 사용 불가.나머지는 public 과 동일 interface블록체인 상에 있으면서 소유하지 않은 컨트랙트와 상호작용을 하려면 우선 interface 를 정의해야 한다. interface 정의 예시코드123contract NumberInterface &#123; function getNum(address _myAddress) public view returns (uint);&#125; dapp 코드에 이런 interface 를 포함하면 컨트랙트는 다른 컨트랙트에 정의된 함수의 특성, 호출 방법, 리턴 값에 대해 알 수 있다. interface 활용하기interface 를 이용하여, 이더리움 블록체인 상의 다른 어떤 컨트랙트와도 상호작용할 수 있다. 이 때, 상호작용하는 함수가 public이나 external로 선언되어 있어야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.19;//zombiefeeding.solimport \"./zombiefactory.sol\";// 크립토좀비가 가장 좋아하는 먹이, 크립토키티와 상호작용할 수 있게하는 KittyInterface 정의contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; // 크립토키티 컨트렉트 주소 KittyInterface kittyContract = KittyInterface(ckAddress); // 크립토키티 인터페이스 생성 및 초기화 // KittyContract가 해당 주소 컨트랙트를 가리킴 function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123; require(msg.sender == zombieToOwner[_zombieId]); // 좀비 주인만 먹이를 줄 수 있도록 Zombie storage myZombie = zombies[_zombieId]; // Zombie 구조체 변수를 storage로 선언, 영구 저장 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; _createZombie(\"NoName\", newDna); // _createZombie 함수는 ZombieFactory 컨트랙트의 internal 함수 &#125;&#125; 다수의 반환값 처리123function multipleReturns() internal returns(uint a, uint b, uint c) &#123; return (1, 2, 3);&#125; 다음과 같이 3개의 값을 반환하는 함수가 있다.이러한 다수의 반환값을 활용하는 방안에는 다수 값 할당 123456function processMultipleReturns() external &#123; uint a; uint b; uint c; (a, b, c) = multipleReturns();&#125; 단 하나의 값에만 관심이 있는 경우 12345function getLastReturnValue() external &#123; uint c; (,,c) = multipleReturns(); // 다른 필드는 빈칸으로 놓으면 됨&#125; 등이 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; // 만약 kitty 라면, DNA 마지막 두 자리로 99 가짐 if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); // 다수의 반환값 중 마지막 반환값에만 관심 // interface를 통해 getkitty 함수 접근 feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.1","slug":"cryptozombies_1","date":"2018-09-04T11:02:50.633Z","updated":"2018-09-07T12:09:12.289Z","comments":true,"path":"2018/09/04/cryptozombies_1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/04/cryptozombies_1/","excerpt":"","text":"컨트랙트이더리움 애플리케이션의 기본적인 구성 요소 (모든 변수/함수 는 어느 한 컨트랙트에 속함)모든 솔리디티 소스 코드는 해당 코드가 이용해야 하는 솔리디티 버전을 선언하며 시작한다. 상태변수컨트랙트 저장소에 영구적으로 저장된다.a.k.a. 이더리움 블록체인에 기록되는 것으로 데이터베이스에 데이터를 쓰는 것과 동일하다. 정수 uint(부호 없는 정수, &gt;= 0) int(부호 있는 정수 실제로 uint는 uint256를 의미한다. (256비트의 부호 없는 정수)uint8, uint16, uint32 등 도 있다. 수학 연산 덧셈 : x + y 뺄셈 : x - y 곱셈 : x * y 나눗셈 : x / y 모듈러 (나머지) : x % y 지수연산 (x의 y제곱) : x ** y 12345678pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; // 좀비 DNA: 16자리 uint dnaModulus = 10 ** dnaDigits; // 16자리보다 큰 수를 16자리 숫자로 줄임&#125; 구조체여러 특성을 가진 자료형을 생성할 수 있다.참고) string: 임의의 길이를 가진 UTF-8 데이터 배열 정적 배열uint[2] fixedArray; 동적 배열uint[] dynamicArray; tip.구조체 배열도 생성 가능하다.상태 변수는 컨트랙트 저장소에 영구적으로 저장되므로,구조체 동적 배열은 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는 데 유용하다. public으로 배열 선언 시 getter 메소드가 자동적으로 생성 되어,다른 컨트랙트들이 이 배열을 읽을 수 있게되므로 (read only), 컨트랙트에 공개 데이터를 저장할 때 유용하다. 123456789101112131415pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; // 좀비의 특성을 멤버로 가지는 구조체 Zombie[] public zombies; // public 좀비 군대 저장소&#125; 함수 선언tip.관례적으로 함수 인자명을 언더바(_)로 시작해서 전역 변수와 구별한다. 구조체 생성새로운 구조체를 생성하고, 이를 구조체 배열에 추가할 수 있다. Private/ Public 함수함수는 기본적으로 public으로 선언된다. 이는 누구나 해당 함수를 호출 및 실행할 수 있음을 의미한다.따라서 보통의 경우 private으로 함수를 선언하는 것이 바람직하다. 이는 동일 컨트랙트 내의 다른 함수들만이 이 함수를 호출할 수 있음을 의미한다. 관례적으로 private 함수명은 언더바(_)로 시작한다. 반환값반환값의 자료형을 포함한다.function sayHello() public view returns (string) { 함수 제어자함수 제어자 예시코드123function _multiply(uint a, uint b) private pure returns (uint) &#123; return a * b;&#125; view: 상태를 변화시키지 않는 함수 (a.k.a. 어떤 값을 변경하지 않음) pure: 앱에서 어떤 데이터도 접근하지 않는 함수 (ex. 앱에서 읽는 것도 없이, 반환값이 함수에 전달된 인자값에 따라 달라지는 함수) Keccak256이더리움은 내장 해시 함수로 SHA3의 한 버전인 keccak256를 가진다. 해 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑한다. 참고: 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제다. 형 변환형 변환 예시코드1234uint8 a = 5;uint b = 6;uint8 c = a * b; // a * b가 uint8이 아닌 uint를 반환하기 때문에 에러uint8 c = a * uint8(b); // 256비트 =&gt; 8비트 형 변환 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; zombies.push(Zombie(_name, _dna)); &#125; // 좀비 생성하여 좀비군대 배열에 push하는 함수 function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; // string으로 부터 랜덤 DNA를 생성하는 함수 function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125; // 좀비의 이름을 입력값으로 받아 랜덤 DNA를 가진 좀비를 만드는 함수&#125; 이벤트컨트랙트가 블록체인 상의 앱 사용자 단에서 어떤 액션이 발생했을 때 의사소통하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는 지 귀 기울이고, 그 이벤트가 발생하면 행동을 취한다. 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); // 좀비가 생성될 때 마다 앱의 사용자 단에서 이를 알고, 표시하도록하는 이벤트 uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); // 새로운 좀비가 배열에 추가된 후에 이벤트 실행 &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"test1","slug":"test1","date":"2018-09-02T10:08:11.069Z","updated":"2018-09-02T14:44:35.211Z","comments":true,"path":"2018/09/02/test1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/02/test1/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test1","slug":"Test1","permalink":"http://SungjuDoh.github.io/categories/Test1/"},{"name":"Test3","slug":"Test1/Test3","permalink":"http://SungjuDoh.github.io/categories/Test1/Test3/"}],"tags":[]},{"title":"Test","slug":"test","date":"2018-09-02T07:50:28.428Z","updated":"2018-09-02T09:48:45.053Z","comments":true,"path":"2018/09/02/test/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/02/test/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test1","slug":"Test1","permalink":"http://SungjuDoh.github.io/categories/Test1/"},{"name":"Test2","slug":"Test1/Test2","permalink":"http://SungjuDoh.github.io/categories/Test1/Test2/"}],"tags":[{"name":"tags1","slug":"tags1","permalink":"http://SungjuDoh.github.io/tags/tags1/"},{"name":"tags2","slug":"tags2","permalink":"http://SungjuDoh.github.io/tags/tags2/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-02T07:15:23.646Z","updated":"2018-09-02T09:49:44.452Z","comments":true,"path":"2018/09/02/hello-world/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test1","slug":"Test1","permalink":"http://SungjuDoh.github.io/categories/Test1/"},{"name":"Test3","slug":"Test1/Test3","permalink":"http://SungjuDoh.github.io/categories/Test1/Test3/"}],"tags":[]}]}
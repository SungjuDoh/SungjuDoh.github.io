{"meta":{"title":"://Sungju.github.io","subtitle":"dev diary","description":null,"author":"Sungju Doh","url":"http://SungjuDoh.github.io"},"pages":[],"posts":[{"title":"Lv.3","slug":"cryptozombies_3","date":"2018-09-08T05:44:31.511Z","updated":"2018-09-09T09:32:52.970Z","comments":true,"path":"2018/09/08/cryptozombies_3/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/08/cryptozombies_3/","excerpt":"","text":"컨트랙트의 불변성이더리움 DApp의 다른 애플리캐이션과는 다른 특징 Immutable 컨트랙트 배포 후, 컨트랙트를 수정하거나 업데이트 불가하다. 컨트랙트로 배포한 최초의 코드는 항상 블록체인에 영구적으로 존재한다. 코드가 곧 법인이 되는 격. 어떤 컨트랙트의 코드를 읽고 검증했다면 이후에 그 누구도 함수를 수정하거나 예상치 못한 결과를 발생시키지 못한다. 외부 의존성따라서, 대개의 경우 DApp의 중요한 일부를 수정 할 수 있도록 하는 함수 를 만들어놓는 것이 합리적이다. 소유 가능한 컨트랙트모든 사람이 우리의 컨트랙트를 업데이트할 수 없도록, 컨트랙트를 대상으로 특별한 권리를 가지는 소유자가 있음을 의미한다. OpenZeppelin 솔리디티 라이브에서 가져온 Ownable 컨트랙트Ownable 컨트랙트1234567891011121314151617181920212223242526272829303132333435/** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */contract Ownable &#123; address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public &#123; owner = msg.sender; &#125; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner &#123; require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; &#125;&#125; 컨트랙트가 생성되면 owner에 컨트랙트를 배포한 사람 을 대입한다. 특정 함수들에 대해 오직 소유자만 접근 할 수 있도록 제한한다. 새로운 소유자에게 해당 컨트랙트의 소유권을 옮길 수 있도록 한다. 대부분의 솔리디티 DApp들은 Ownable컨트랙트를 복사/붙여넣기 하면서 시작한다. 그리고 첫 컨트랙트는 이 컨트랙트를 상속하여 만든다. 참고 생성자(Constructor) : 컨트랙트가 생성될 때 딱 한 번만 실행된다. 컨트랙트와 동일 이름을 가진다. 함수 제어자(Function Modifier) : 다른 함수들에 대한 접근을 제어하기 위한 일종의 유사 함수다. 보통 함수 실행 전의 요구사항 충족 여부를 확인하는 데에 사용한다. 가스(Gas)“이더리움 DApp이 사용하는 연료” 솔리디티에서는 사용자들이 DApp의 함수를 실행할 때마다 가스 라는 화폐를 지불해야한다. 사용자는 이더(ETH, 이더리움 화폐) 를 이용해서 가스를 사기 때문에, DApp 함수를 실행하려면 사용자들은 ETH 를 소모해야한다. 함수를 실행하는 데에 필요한 가스량은 그 함수의 로직 이 얼마나 복잡한지에 따라 달라진다. 1. 가스 비용(gas cost)각 연산은 소모되는 가스비용을 가지고, 해당 연산 수행에 소모되는 컴퓨팅 자원의 양이 이 비용을 결정한다.예를 들어, storage에 값을 쓰는 것 &gt; 두 정수를 더하는 것 이더리움에서 코드 최적화는 다른 프로그래밍 언더들에 비해 훨씬 중요하다. 코드가 엉망이라면, 사용자들은 함수를 실행하기 위해 일종의 할증료를 더 내야하기 때문이다. 2. 가스는 왜 필요한가?이더리움은 크고 느리지만 굉장히 안전한 컴퓨터와 같다.어떤 함수를 실행할 때, 네트워크상의 모든 개별 노드가 함수의 출력값을 검증하기 위해 그 함수를 실행해야 한다. 모든 함수의 실행을 검증하는 수천 개의 노드 가 이더리움을 분산화하고, 데이터를 보존하며 누군가 검열할 수 없도록 하는 요소이다. 이더리움을 만든 사람들은 누군가가 무한 반복문을 써서 네트워크를 방해하거나, 자원 소모가 큰 연산으로 네트워크 자원을 모두 사용하지 못하도록 만들길 원했다. 그래서 연산 처리에 비용이 들도록 만들었고, 사용자들은 저장 공간과 연산 사용 시간 에 따라서 비용을 지불해야 한다. 참고: 다른 합의 알고리즘을 가진 사이드체인 에서는 반드시 이렇지는 않다. 따라서 DApp을 사이드체인과 이더리움 메인넷 중 어디에 올릴 지 판단하는 방법들도 추후에 배우게 된다. 3. 가스를 아끼기 위한 구조체 압축uint는 크기에 상관없이 256비트의 저장 공간을 미리 잡아 놓는다.하지만 struct 안에서는 변수들을 더 적은 공간을 차지하도록 압축할 것이므로, 가능한 더 작은 크기의 uint를 쓰는 것이 좋다.또한, 동일한 데이터 타입은 하나로 묶어놓는 것이 좋다.uint c; uint32 a; uint32 b; 의 경우, uint32 필드가 묶여있다. 시간 단위솔리디티는 시간을 다룰 수 있는 단위계를 기본적으로 제공한다. now 변수를 사용하면 현재의 유닉스 타임스탬프(1970.01.01부터 지금까지의 초 단위 합)값을 얻을 수 있다. 참고유닉스 타임은 전통적으로 32비트 숫자로 저장된다. 따라서 2038년 부터 문제를 일으킬 것이므로, 20년 이상 운영되길 원한다면 64비트 숫자를 써야하고, 이때 가스 비용 또한 고려해야한다. 솔리디티는 또한 seconds, minutes, hours, days, weeks, years 같은 시간 단위 를 포함한다. 이들은 그에 해당하는 길이 만큼의 초 단위 uint 숫자로 변환된다. 1 hours와 같이 사용한다. 구조체를 인수로 전달private 또는 internal 함수에 인수로서 구조체의 storage 포인터 를 전달할 수 있다. 구조체 인수 전달 예시코드12function _doStuff(Zombie storage _zombie) internal &#123;&#125; // 여기서 Zombie 는 구조체명 Public 함수와 보안public과 external 함수는 특수한 제어자를 갖지 않는 이상, 어떤 사용자든 이 함수들을 호출하고 자신들이 원하는 모든 데이터를 함수에 전달할 수 있다.따라서 보안 점검을 위해 이 함수들을 검사하고, 사용자들이 이들을 남용할 수 있는 방법을 생각해봐야한다. 함수를 internal로 만드는 것도 한 가지 예다. 인수를 가지는 함수 제어자예시코드123456789101112// 사용자의 나이를 저장하기 위한 매핑mapping (uint =&gt; uint) public age;// 사용자가 특정 나이 이상인지 확인하는 제어자modifier olderThan(uint _age, uint _userId) &#123; require (age[_userId] &gt;= _age); _;&#125;// `olderThan` 제어자를 인수와 함께 호출function driveCar(uint _userId) public olderThan(16, _userId) &#123;&#125; View 함수를 사용해 가스 절약하기view 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않는다. 이는 view함수가 블록체인 상에서 실제로 어떤 것도 수정하지 않고 데이터를 읽기만 하기 때문이다. 이 함수는 실행할 때 로컬 이더리움 노드 에 질의만 하고, 블록체인에 어떤 트랜잭션도 만들지 않는다. 트랜잭션 : 모든 개별 노드에서 실행되어야 하고, 가스를 소모한다. 따라서, 가스 사용을 최적화하는 비결은 가능한 모든 곳에 읽기 전용 의 external view 함수를 쓰는 것이다. 참고view함수가 동일 컨트랙트 내에 있는 다른 함수에서 내부적 으로 호출되는 경우에는 가스가 소모된다. 다른 함수가 이더리움에 트랜잭션 을 생성하기 때문이다. 메모리에 배열 선언하기storage데이터를 사용하는 것은 비싼 연산이다. (특히 쓰기 연산) 해당 데이터를 쓰거나 바꿀 때마다 수천 ㄱ의 노드들이 그들의 하드 드라이브에 데이터를 저장해야하기 때문이다. 비용을 최소화 하기위해, 정말 필요한 경우가 아니면 storage데이터를 사용하지 않는 것이 좋다. 이를 위해 때때로는 겉보기에 비효율적으로 보이는 프로그래밍 구성이 필요하다. 어떤 배열에서 내용을 빠르게 찾기 위해, 단순히 변수에 저장하는 것 대신 함수가 호출될 때마다 배열을 memory에 다시 만드는 것 이 한 가지 예시이다. uint[] memory values = new uint[](3);memory 키워드를 사용하면 되고, 반드시 길이 인수 와 함께 생성되어야 한다. 이 배열은 함수가 끝날 때까지만 존재할 것이고, 만약 이 함수가 외부에서 호출되는 view함수라면 비용은 무료이다. For 반복문때때로 함수 내에서 배열을 다룰 때, storage에 해당 배열을 저장하지 않고 for반복문을 사용해서 구성해야 할 필요가 있다. 우리 코드를 예시로 생각해보자.getZombiesByOwner 함수를 구현할 때, 가장 기초적인 구현 방법은 ZombieFactory컨트랙트에서 소유자의 좀비군대에 대한 mapping을 만들어서 저장하는 것이다.mapping (address =&gt; uint[]) public ownerToZombies; 이후에 새로운 좀비를 만들 때마다, 해당 소유자의 좀비 배열에 추가하는 것이다.ownerToZombies[owner].push(zombieId);이렇게 되면 getZombiesByOwner 함수는 다음과 같이 아주 이해하기 쉬운 함수가 된다.123function getZombiesByOwner(address _owner) external view returns (uint[]) &#123; return ownerToZombies[_owner];&#125; 이 방식의 문제점만약 나중에 한 좀비를 원래 소유자에서 다른 사람에게 전달하는 함수를 구현하게 되면 문제가 생긴다. 기존 소유자의 좀비 배열에서 해당 좀비를 지운 후, 좀비가 지워진 구멍을 메우기 위해 기존 소유자의 배열에서 모든 좀비를 한 칸씩 움직여서 배열의 길이를 지워야한다. storage 연산의 가스 비용이 아주 높고, 함수가 실행될 때마다 다른 양의 가스가 소모되기 때문에 이를 예측할 수 도 없다. Solutionview 함수는 외부 호출 시 가스를 소모하지 않기 때문에, for반복문을 사용하여 좀비 배열의 모든 요소에 접근하여 특정 사용자의 좀비들로 구성된 배열 을 만들 수 있을 것이다. 이렇게 되면 transfer 함수는 훨씬 비용을 적게 쓰게된다. web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.2","slug":"cryptozombies_2","date":"2018-09-07T12:15:36.396Z","updated":"2018-09-08T05:17:59.904Z","comments":true,"path":"2018/09/07/cryptozombies_2/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/07/cryptozombies_2/","excerpt":"","text":"주소와 매핑데이터베이스에 저장된 좀비들에게 주인을 설정하여 멀티 플레이어 게임으로 만든다.mapping과 address 두 자료형이 필요하다. 주소이더리움 블록체인은 은행 계좌와 같은 계정 들로 이뤄져있다. 계정은 이더리움 블록체인상의 통화인 이더 의 잔액을 가진다. 계정을 통해 다른 계정과 이더를 주고 받을 수 있다. 각 계정은 은행 계쫘 번호와 같은 주소 를 가지고 있다. 주소는 특정 계정을 가리키는 고유 식별자이다. “ 주소는 특정 유저(혹은 스마트 컨트랙트)가 소유한다. “ 매핑솔리디티에서 구조화된 데이터를 저장하는 또다른 방법이다. 다음과 같이 매핑을 정의할 수 있다.mapping (address =&gt; uint) public accountaBallance; 매핑은 기본적으로 key-value 저장소로, 데이터를 저장하고 검색하는 데 이용된다.key =&gt; value 12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; // 좀비 id =&gt; 좀비 소유자 주소 mapping (address =&gt; uint) ownerZombieCount; // 좀비 소유자 주소 =&gt; 좀비 수 function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; msg.sender솔리디티에는 모든 함수에서 이용 가능한 특정 전역 변수 들이 있다. Msg.sender : 현재 함수를 호출한 사람(혹은 스마트 컨트랙트)의 주소(address)를 가리키는 변수 Tip. 솔리디티에서 함수 실행은 항상 외부 호출자가 한다. 따라서 항상 msg.sender의 값은 존재한다. 컨트랙트는 누군가가 컨트랙트의 함수를 호출할 때까지 블록체인 상에서 아무 것도 하지 않는다. msg.sender를 활용하면, 이더리움 블록체인의 보안성을 이용할 수 있다. 누군가 다른 사람의 데이터를 변경하려면 해당 이더리움 주소와 관련된 개인키를 훔치는 방법 뿐이다. require특정 조건이 참이 아닐 때 함수가 에러 메시지를 발생하고 실행을 멈춘다. 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; // 새로운 좀비의 id zombieToOwner[id] = msg.sender; // 좀비 id =&gt; 좀비 소유자 주소 ownerZombieCount[msg.sender]++; // 좀비 소유자가 가진 좀비 수 증가 NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); // 유저가 군대에 좀비를 무제한으로 생성하는 것을 방지 uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; 상속상속 예시코드1234567891011contract Doge &#123; function catchphrase() public returns (string) &#123; return \"So Wow CryptoDoge\"; &#125;&#125;contract BabyDoge is Doge &#123; function anotherCatchphrase() public returns (string) &#123; return \"Such Moon BabyDoge\"; &#125;&#125; 위 코드에서 BabyDoge 컨트랙트는 Doge 컨트랙트를 상속한다.BabyDoge가 컴파일되어 구축될 때, Doge 컨트랙트에 정의되는 어떤 public 함수에도 접근이 가능하다. 보통 부분집합 관계에서 상속 이 사용된다. Import다수의 파일이 있고, 어떤 파일을 다른 파일로 불러오고 싶을 때 사용한다.import &quot;./someothercontract.sol&quot;; 코드가 길어져서 여러 파일로 나누어 정리하고, import라는 키워드로 다른 파일을 불러온다. 1234567//zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\"; // importcontract ZombieFeeding is ZombieFactory &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839//zombiefactory.solpragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; mapping (uint =&gt; address) public zombieToOwner; mapping (address =&gt; uint) ownerZombieCount; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; zombieToOwner[id] = msg.sender; ownerZombieCount[msg.sender]++; NewZombie(id, _name, _dna); &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; require(ownerZombieCount[msg.sender] == 0); uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; Storage &amp; Memory솔리디티에서 변수를 저장할 수 있는 공간 Storage블록체인 상에 영구적으로 저장되는 변수컴퓨터의 하드 디스크와 비슷하다. Memory임시적으로 저장되는 변수로, 컨트랙트 함수에 대한 외부 호출들이 일어나는 사이에 지워진다.컴퓨터의 RAM과 비슷하다. 대부분의 경우, 이런 키워드를 사용할 필요가 없다.솔리디티에서 자동으로 상태변수(함수 외부에 선언된 변수) : storage 로 선언되어, 영구적으로 저장 함수 내에 선언된 변수 : memory 로 선언되어, 함수 호출이 종료되면 사라짐 하지만 키워드가 필요한 경우가 있다. 구조체와 배열키워드 사용 코드예시123456789101112131415161718192021222324contract SandwichFactory &#123; struct Sandwich &#123; string name; string status; &#125; // 구조체 Sandwich[] sandwiches; // 구조체 배열 function eatSandwich(uint _index) public &#123; Sandwich storage mySandwich = sandwiches[_index]; // `sandwiches[_index]`를 가리키는 포인터 mySandwich.status = \"Eaten!\"; // 따라서 `sandwiches[_index]`을 영구적으로 변경 Sandwich memory anotherSandwich = sandwiches[_index + 1]; // `anotherSandwich`는 단순히 메모리에 데이터를 복사 anotherSandwich.status = \"Eaten!\"; // 임시 변수인 `anotherSandwich`를 변경 // `sandwiches[_index + 1]`에는 아무런 영향을 끼치지 않음 sandwiches[_index + 1] = anotherSandwich; // 다른 활용 방안 : 임시 변경한 내용을 블록체인 저장소에 저장 &#125;&#125; 함수 접근 제어자 public모든 컨트랙트에서 사용 가능 private함수가 정의된 컨트랙트에서만 사용 가능 internal함수가 정의된 컨트랙트와 이를 상속하는 컨트랙트에서도 사용 가능 external컨트랙트 바깥에서만 호출될 수 있고, 컨트랙트 내의 다른 함수에서는 사용 불가.나머지는 public 과 동일 interface블록체인 상에 있으면서 소유하지 않은 컨트랙트와 상호작용을 하려면 우선 interface 를 정의해야 한다. interface 정의 예시코드123contract NumberInterface &#123; function getNum(address _myAddress) public view returns (uint);&#125; dapp 코드에 이런 interface 를 포함하면 컨트랙트는 다른 컨트랙트에 정의된 함수의 특성, 호출 방법, 리턴 값에 대해 알 수 있다. interface 활용하기interface 를 이용하여, 이더리움 블록체인 상의 다른 어떤 컨트랙트와도 상호작용할 수 있다. 이 때, 상호작용하는 함수가 public이나 external로 선언되어 있어야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.19;//zombiefeeding.solimport \"./zombiefactory.sol\";// 크립토좀비가 가장 좋아하는 먹이, 크립토키티와 상호작용할 수 있게하는 KittyInterface 정의contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; // 크립토키티 컨트렉트 주소 KittyInterface kittyContract = KittyInterface(ckAddress); // 크립토키티 인터페이스 생성 및 초기화 // KittyContract가 해당 주소 컨트랙트를 가리킴 function feedAndMultiply(uint _zombieId, uint _targetDna) public &#123; require(msg.sender == zombieToOwner[_zombieId]); // 좀비 주인만 먹이를 줄 수 있도록 Zombie storage myZombie = zombies[_zombieId]; // Zombie 구조체 변수를 storage로 선언, 영구 저장 _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; _createZombie(\"NoName\", newDna); // _createZombie 함수는 ZombieFactory 컨트랙트의 internal 함수 &#125;&#125; 다수의 반환값 처리123function multipleReturns() internal returns(uint a, uint b, uint c) &#123; return (1, 2, 3);&#125; 다음과 같이 3개의 값을 반환하는 함수가 있다.이러한 다수의 반환값을 활용하는 방안에는 다수 값 할당 123456function processMultipleReturns() external &#123; uint a; uint b; uint c; (a, b, c) = multipleReturns();&#125; 단 하나의 값에만 관심이 있는 경우 12345function getLastReturnValue() external &#123; uint c; (,,c) = multipleReturns(); // 다른 필드는 빈칸으로 놓으면 됨&#125; 등이 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344// zombiefeeding.solpragma solidity ^0.4.19;import \"./zombiefactory.sol\";contract KittyInterface &#123; function getKitty(uint256 _id) external view returns ( bool isGestating, bool isReady, uint256 cooldownIndex, uint256 nextActionAt, uint256 siringWithId, uint256 birthTime, uint256 matronId, uint256 sireId, uint256 generation, uint256 genes );&#125;contract ZombieFeeding is ZombieFactory &#123; address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; KittyInterface kittyContract = KittyInterface(ckAddress); function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public &#123; require(msg.sender == zombieToOwner[_zombieId]); Zombie storage myZombie = zombies[_zombieId]; _targetDna = _targetDna % dnaModulus; uint newDna = (myZombie.dna + _targetDna) / 2; // 만약 kitty 라면, DNA 마지막 두 자리로 99 가짐 if (keccak256(_species) == keccak256(\"kitty\")) &#123; newDna = newDna - newDna % 100 + 99; &#125; _createZombie(\"NoName\", newDna); &#125; function feedOnKitty(uint _zombieId, uint _kittyId) public &#123; uint kittyDna; (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId); // 다수의 반환값 중 마지막 반환값에만 관심 // interface를 통해 getkitty 함수 접근 feedAndMultiply(_zombieId, kittyDna, \"kitty\"); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Lv.1","slug":"cryptozombies_1","date":"2018-09-04T11:02:50.633Z","updated":"2018-09-07T12:09:12.289Z","comments":true,"path":"2018/09/04/cryptozombies_1/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/04/cryptozombies_1/","excerpt":"","text":"컨트랙트이더리움 애플리케이션의 기본적인 구성 요소 (모든 변수/함수 는 어느 한 컨트랙트에 속함)모든 솔리디티 소스 코드는 해당 코드가 이용해야 하는 솔리디티 버전을 선언하며 시작한다. 상태변수컨트랙트 저장소에 영구적으로 저장된다.a.k.a. 이더리움 블록체인에 기록되는 것으로 데이터베이스에 데이터를 쓰는 것과 동일하다. 정수 uint(부호 없는 정수, &gt;= 0) int(부호 있는 정수 실제로 uint는 uint256를 의미한다. (256비트의 부호 없는 정수)uint8, uint16, uint32 등 도 있다. 수학 연산 덧셈 : x + y 뺄셈 : x - y 곱셈 : x * y 나눗셈 : x / y 모듈러 (나머지) : x % y 지수연산 (x의 y제곱) : x ** y 12345678pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; // 좀비 DNA: 16자리 uint dnaModulus = 10 ** dnaDigits; // 16자리보다 큰 수를 16자리 숫자로 줄임&#125; 구조체여러 특성을 가진 자료형을 생성할 수 있다.참고) string: 임의의 길이를 가진 UTF-8 데이터 배열 정적 배열uint[2] fixedArray; 동적 배열uint[] dynamicArray; tip.구조체 배열도 생성 가능하다.상태 변수는 컨트랙트 저장소에 영구적으로 저장되므로,구조체 동적 배열은 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는 데 유용하다. public으로 배열 선언 시 getter 메소드가 자동적으로 생성 되어,다른 컨트랙트들이 이 배열을 읽을 수 있게되므로 (read only), 컨트랙트에 공개 데이터를 저장할 때 유용하다. 123456789101112131415pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; // 좀비의 특성을 멤버로 가지는 구조체 Zombie[] public zombies; // public 좀비 군대 저장소&#125; 함수 선언tip.관례적으로 함수 인자명을 언더바(_)로 시작해서 전역 변수와 구별한다. 구조체 생성새로운 구조체를 생성하고, 이를 구조체 배열에 추가할 수 있다. Private/ Public 함수함수는 기본적으로 public으로 선언된다. 이는 누구나 해당 함수를 호출 및 실행할 수 있음을 의미한다.따라서 보통의 경우 private으로 함수를 선언하는 것이 바람직하다. 이는 동일 컨트랙트 내의 다른 함수들만이 이 함수를 호출할 수 있음을 의미한다. 관례적으로 private 함수명은 언더바(_)로 시작한다. 반환값반환값의 자료형을 포함한다.function sayHello() public view returns (string) { 함수 제어자함수 제어자 예시코드123function _multiply(uint a, uint b) private pure returns (uint) &#123; return a * b;&#125; view: 상태를 변화시키지 않는 함수 (a.k.a. 어떤 값을 변경하지 않음) pure: 앱에서 어떤 데이터도 접근하지 않는 함수 (ex. 앱에서 읽는 것도 없이, 반환값이 함수에 전달된 인자값에 따라 달라지는 함수) Keccak256이더리움은 내장 해시 함수로 SHA3의 한 버전인 keccak256를 가진다. 해 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑한다. 참고: 블록체인에서 안전한 의사 난수 발생기는 매우 어려운 문제다. 형 변환형 변환 예시코드1234uint8 a = 5;uint b = 6;uint8 c = a * b; // a * b가 uint8이 아닌 uint를 반환하기 때문에 에러uint8 c = a * uint8(b); // 256비트 =&gt; 8비트 형 변환 1234567891011121314151617181920212223242526272829pragma solidity ^0.4.19;contract ZombieFactory &#123; uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; zombies.push(Zombie(_name, _dna)); &#125; // 좀비 생성하여 좀비군대 배열에 push하는 함수 function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; // string으로 부터 랜덤 DNA를 생성하는 함수 function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125; // 좀비의 이름을 입력값으로 받아 랜덤 DNA를 가진 좀비를 만드는 함수&#125; 이벤트컨트랙트가 블록체인 상의 앱 사용자 단에서 어떤 액션이 발생했을 때 의사소통하는 방법이다. 컨트랙트는 특정 이벤트가 일어나는 지 귀 기울이고, 그 이벤트가 발생하면 행동을 취한다. 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.19;contract ZombieFactory &#123; event NewZombie(uint zombieId, string name, uint dna); // 좀비가 생성될 때 마다 앱의 사용자 단에서 이를 알고, 표시하도록하는 이벤트 uint dnaDigits = 16; uint dnaModulus = 10 ** dnaDigits; struct Zombie &#123; string name; uint dna; &#125; Zombie[] public zombies; function _createZombie(string _name, uint _dna) private &#123; uint id = zombies.push(Zombie(_name, _dna)) - 1; NewZombie(id, _name, _dna); // 새로운 좀비가 배열에 추가된 후에 이벤트 실행 &#125; function _generateRandomDna(string _str) private view returns (uint) &#123; uint rand = uint(keccak256(_str)); return rand % dnaModulus; &#125; function createRandomZombie(string _name) public &#123; uint randDna = _generateRandomDna(_name); _createZombie(_name, randDna); &#125;&#125; web.js 나중에 공부하기~!ex1123contract testContract&#123;&#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://SungjuDoh.github.io/categories/BlockChain/"},{"name":"Crypto Zombies (Solidity)","slug":"BlockChain/Crypto-Zombies-Solidity","permalink":"http://SungjuDoh.github.io/categories/BlockChain/Crypto-Zombies-Solidity/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://SungjuDoh.github.io/tags/blockchain/"},{"name":"solidity","slug":"solidity","permalink":"http://SungjuDoh.github.io/tags/solidity/"},{"name":"cryptozombies","slug":"cryptozombies","permalink":"http://SungjuDoh.github.io/tags/cryptozombies/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-02T07:15:23.646Z","updated":"2018-09-02T09:49:44.452Z","comments":true,"path":"2018/09/02/hello-world/","link":"","permalink":"http://SungjuDoh.github.io/2018/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Test1","slug":"Test1","permalink":"http://SungjuDoh.github.io/categories/Test1/"},{"name":"Test3","slug":"Test1/Test3","permalink":"http://SungjuDoh.github.io/categories/Test1/Test3/"}],"tags":[]}]}